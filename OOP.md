**10/1/2018**

1.3) структурні моделі
1.3.1) Об’єкти, та відношення між ними.

Об’єкт представляє собою конкретну сутність (предмер, або поняття), що має ідентичність - чітко визначенне функціональне призначення у данній предметній області.

ідентичність відрізняє Об’єкт від інших Об’єктів і визначяється поведінкою та властивостями. Об’єкти створюються, вступають у увідношення з іншими об'єктами, змінюють свій стан і знищуюються. 

Властивості Об’єкта визначаються переліком атрибутів. Та характеризують об'єкт. 

Множина (статична) всіх атрибутів Об’єкта та їх припустимих значень визначає множину станів Об’єкта. Поточне значення властивостей визначє поточний стан об'єкта.

Поведінка Об’єкта - це його діяльність що може бути виражена відправленням та отриманням повідомлення. Отримання повідомлення призводить до виконання Об’єктом визначенної операції - послуги яку отримувачь надає відправнику.

Відносно до стану об'єкта всі операції Об’єкта можуть бути кваліфікованні як:
1. Модифікатор - змінює атрибут
1. Селектор - надає інформацію про значення атрибута.
1. Ітератор - надає послідовний доступ до множини атрибутів.
1. Конструктор - встановлює початковий стан Об’єкта.
1. Декструктор - вивільняє стан об'єкта.

Відношення між Об’єктами - можливість одних Об’єктів відправляти або отримувати повідомлення від інших через агрегацію, асоціацію, використання.

*Агрегація* - вид направленного відношення між об'єктами типу "ціле - частка". Наслідок - можливість впорядкування об'єктів в ієрархію. Існує 2 типи агрегації: 
1. Композиція - частка є обов'язковою
1. Коллекція - частка - необов'язкова

*Асоціація* - вид відношення співпраці між об'єктами коли об'єкт може відігравати одну з ролей:
1. Клієнт - Об’єкт відправляє повідомлення іншому об'єкту але не отримує повідомлень від нього.
1. Сервер - Об’єкт, що отримує повідомлення від ішного об'єкта, але не відправляє повідомлення йому.
1. Агент - отрибує та відправляє повідомлення ішному/від іношого об'єкту.

*Використання* (залежність) - відношення, коли 1 об'єкт передається в окремі операції іншого об'єкта.

Відношення між об'єктами можуть бути представленні через діаграму об'єктів, базуються на відношеннях між классами і встановлюються на етапі виконання программи.

**1.3.2 Класси та відношення між ними**
Класс - це абстракція що описує спільні поведінку та властивості деякоі множини об'єктів.

Класс може знаходитись у відношеннях з іншими классами, та бути придставленних через декларацію, визначення, та реалізацію (в окремих мовах ці представлення є нерозривними).

Декларація класса - визначення його імені, як кастомного типу. 

Визначення классу - декларація множити атрибутів і операцій классу. Після визначення класу можуть бути створення об'єкти йього классу. 

Реалізація классу - визначення задекларованних операцій классу.

За можливостями використання атрибутів та операцій класс может бути поділенний на секції:
1. public - для зовнішнього використання
1. private - лише для внутрішнього виконання та дружнім
1. protected - єлементи надаютсья лише похідним классам та дружнім

Відновно до можливостей зовнішнього використання операції классу можуть бути кваліфікованні як:
1. змістовні (API) - визанчають інтерфейс классу через функції визначенні у відкритій частині
1. спеціальні - забезпечюють ініціалізацію, присвоювання, перетворення типу, тощо (викликаються не явно).
1. допоміжні - забезпечують окремі аспекти діяльності, викликаються зі змістовних чи спеціальних операцій (**Не вызывать вспомогательные функции в вспомогательных функциях**)

Всі допоміжні функції є захищенними або закритими.

*Класс, що надає назовні виключно перелік операцій і приховує атрибути - абстрактний тип данних.*

Відношення між классами - це задекларованна можливість, що дозволяє:
1. Встановлюванни відношення між об'єктами цик класів (агрегацію, асоціацію, використання).
1. Використовавути в одному класі операції та атрибути іншого через успадкування, конкретизацію, та мета-клас.

## 10/29/2018
**Агрегація классів** Реалізується шляхом:
1. Визначеня одного класа в іншому, що дозволяє використовувати об'єкти вкладенного классу виключно в межах охоплюючого, шляхом створення атрибутів-об'єктів, або атрибутів-показчиків вкладенного классу в охоплюючому.
1. Визначення в класі атрибутів об'єктів або атрибутів показчиків іншого класу.
1. При цьому композиція забезпечюється визначення атрибутів-об'єктів, а Коллекція - атрибутів-показчиків

Асоціація класів визначається атрибутами-покзчиками в одному класі на об'єкти іншого. Асоціація характеризується потужністю:
1. Один до одного
1. Один до багатьох
1. Багато до багатьох

Агрегація-Коллекція, та ассоціація реалізується розміщенням в классі покажчика на об'єкти іншого класса, відмінності між ними в тому, що:
1. для Коллекції - охоплюючий об'єкт створює вкладенний
1. для ассоціації - охоплюючий об'єкт отримує його ззовні.

Використання реалізується через визначення функцій класу, що в аргументах отримують об'єкти ішних класів.

-----

**Успадкування класів** - декларація направленного відношення (is-a - магазин є будівлею), коли один клас розширює структуру, розширює або уточню поведінку іншого класа (одиночне успадкування), або інших класів (множинне).

Верхние класси - базові/суперкласи

**Конкретизація/Инстанцирование/Обобщенное программирование** - можливість створювати екземпляри одного класу через макровизначення або шаблон іншого шляхом заміни формальних типів параметрі фактичними (Templates/Generics).

**Мета-клас** - класс, екземплярами якого є класи (только в интерпретируемых языках программирования)

----

Відношення між об'єктами встановлюються на єтапі виконання программи
Відношення між класами можуть бути представленні в діаграму класів і встановлюються на єтапі розробки програми (як вийняток для мета-класів на етапі виконання).

----

1.4 Моделювання поведінки
---

**1.4.1. Взаємодія об'єктів**
Модель взаємодії обїектів відображає послідовність передачі повідомлень між об'єктами у часі.
Проміжок часу, протягом якого об'єкт існує може приймати та відправляти повідомлення складає лінію життя об'єкта.
Частина лінії життя, протягом якої об'єкт виконую поточну операцію називається фокусом управління (**cequence diagram**).

**1.4.2. Діяльність об'єкта**
Наслідком виконання об'єктом сукупності операцій є зміна станів об'єкта. В термінах переходів станів об'єкт може розглядатися як автомат.

**1.4.3. Операції об'єкта**
При отримані об'єктом повідомлення він починає виконувати відповідну операцію (функцію - змістовну/сеціальну). В свою чергу така операція може може розпочати виконання допоміжних операцій. Послідовніть таких операцій модулюється через блок-схему алгоритму.

1.5 Механізми ОО мов програмування
---

Базовими механізмами ОО мов програмування є *Інкапсуляція, Успадкування, Поліморфізм*

**Інкапсуляція** - механізм об'єднання данних та функцій для їх обробки в класс з чітким визначенням інтерфейсу та приховуванням деталей реалізації. Наслідком Інкапсуляції є зменшення обсягу інформації необхідної на кожному кроці розробки программи.

**Успадкування** - механізм створення нових класів на основі існуючих шляхом додавання нових властивостей, заміни або додавання нових операцій. При цьому в підкласах визначаються лише відмінності від базових класів. Наслідком успадкування є можливість повторного використання коду.

**Поліморфізм** - механізм, що дозволяє використовувати в ієрархії классів однакові імена для подібних але різних операцій з можливістю виклику операцій відповідно до типу динамічно створених в программі об'єктів. Наслідком Поліморфізму є уникнення необхідності перевідки типів об'єктів.

---
ООП в С++
---

**2.1. Нововведення С++**

**2.1.1. Декларації та типи**
С++ ОО надбудова над мовою С. В С++ введені, чи зміненні наступлі єлементи:
1. // (В С спочатку був лише /* */)
1. NULL (void *) та 0-показчик (int)
1. Підсилена перевідка типів 
1. C++ порожній список аргументів функції розглядається як функція без аргументів, в мові С як функция з довільним числом аргументів
1. Реалізована можливість декларації зміної практично у будь-якому місці блоку
1. Введений тип данних bool
1. Введеный тип данных wchar_t для представлення символів у unicode (1 символ - 2 байти) (wchar_t a = L"Hello")
1. const. Для показчиків може бути записаний як: cons char *str = "Hello" - незмінні символи - показчик на константу char const *s = "Hello" - незмінний показчик - константний показчик. const char const *s = "Hello" - незмінні не символи ні показчик - константний покажчик на константу
1. Перевантаження функций. Екщо потрібен С: extern "c" {/* С код */}
1. Аргументи функций за замовчуванням (підстановка виконуєтся зліва на право при виклику функції).
1. Введенні поіменовані області імен та оператор доступу до області імен. Звернення до об'єкта глобальної області імен: ::name
1. Віділяє динамічну память, викликає конструктор та перетворюює тип резултату
1. delete викликає Декструктор і вивільняє динамічну память
1. Реалізовані функції як єлементи структур. 

2.1.2. Посилання
---

Посилання - визначають нове ім'я як синонім імені існуючого об'єкта.
```cpp
int a;
int &b = a;
```
ініціалізацію - при декларації.

2.1.3. iostream:
- cin, cout, cerr (відповідають stdin, stdout, stderr, але не заміщюють іх)
- для Об’єктів cin, cout, cerr перевантажені оператори: >>/<<
- 
2.2 Опис клсау:
---

**2.2.1. Опис класу та визначення:**

Декларація класу (попередня декларація): class Point;

Після декларації можуть бути створені об'єкти цього класу.

Визначення класу виконується як:

class Point {

};

**Класи в С++ мають відрізнятись від вбудованих типів виключно сповобом отримання а не способом використання**

Досягається за рахунок перевантаження операторів.

**2.2.2. Атрибути класу:**
визначення і використання подібне до структур.
```cpp
class Point {
   int x;
   int y;
};
```

**2.2.3 - функції класу**
Функції декларують, або декларують і визначають у класі як:
```cpp
class Point {
   int a();
   double b() {return 0.0};
}

int Point::a() {
   return 0;
}
```
Визначенні в класі фукнції розглядаються як inline.
В класі визначати лише невеликі функції.

**2.2.4**
public, private, protected
default: public - public для структур, private - для класів

Приховування елементів забузпечує клас, а не його об'єкти. Це значить, що з будь-якої функції об'єкта класу можна звернутись до всіх єлементів інших об'єктів його ж класу

**2.3 Объекти класу**
**2.3.1 визначення об'єктів**

```cpp

Point p1, p2;
Point *p3;
```
Об'єкти можна ініцілізувати іншими об'єктами тих же об'єктів. 

Показчики можна ініціалізувати:
```cpp
   Point p2;
   Point *p3 = &p2
   Point *p4 = new Point;
```

Функції классу зберігаються поза межами об'єкту классу. Для них лиже забезбечуєтся контекст об'єктів.

Можно ініціалізувати об'єктом того ж класу, что призводить до копіювання всіх атрибутів.
Point p1;
Point p2 = p1;

Показчик на об'єкт может буті ініціалізований через операцію обчислення адреси, або оператор new

2.3.2. Об'єкти класу та функції.
---

Об'єкт может бути переданний у функцію як аргумент і отриманий як результат. Відповідно до правил передачі аргументів та результатів в с++ будут створенні тимчасові об'їкти - копії фактичних аргументів або результату, що може мати негативні наслідки. Для уникнення цих наслідків об'єкти можно передавати через посилання або показчики.

void f1(Point p);
+ void f2 (Point &p);
  void f3 (Point *p);

  Point f4();
+ Point & f5();
  Point * f6();

2.4. Функції класу:
---

2.4.1. Модифікатори
---

**Модифікатор** встановлює (змінює) значення атрибута/атрибутів об'єкта. Згідно до свого призначення так функция визначаєтся як, наприклад сетер.

Функції великого розміру можуть бути визначенні за межами класу.

Модифікатор може мати тип:
1. void - встановлення атрибуту без перевырки
1. bool - з перевіркою
1. Тип атрибуту - з поверненням попереднього значення атрибуту
1. ...

2.4.2. Селектори
**Селектор** - повертає значення атрибута об'єкта (наприклад, геттер). Згідно свого призначення визначається як константна функція, та має тип атрибута об'єкта.
Також можливі інши типи крім void

void getX() const;
void getY() const {}

Якщо об'єкт є константним до нього можут бути застосовані виключно сонстанті функції.
Константна функція може бути перевантажена не константною

2.5. Показчик this
---

Для забезпечення ф функція классу доступу до атрибутів окремих об'єктів классу функції класу неявно передається костантний коказчик на об'єкт класу.
При цьому виклик функції класу змінюється як:

p1.show() -> Point::show(&p1);

Для константных функцій:
Point::show() const {};
p1.show() -> Point::show(const &p1);

Безпосередне викориснання this може знадобитися у випадках:

1. з аргументами функцій.
1. об'єкт має передати свою адресу іншому об'єкту для встановленя асоціації між об'єктами

2.6. Статичні єлементи класу:
---

2.6.1. Статичні атрибути
---

Відносно свого класу такі атрибути являються "глобальню зміною", але використовються згідно специфікаторів доступу, та не конфліктуюсть з іншими іменами.

Внаслідок того, що статичний атрибут не належить жодному з об'єктів він має створюватись окремо від об'єктів як:

Point {
private:
   static int _a;
}

static int Poindt::_a = 5;

Рекомендуєтся звертатись через ім'я классу.

2.6.2. Статичні Функції
---

Не отримують контекст об'єкта (тому не можеть бути константними).

2.7. Friends
---

Friend - не элемент класу (глобальна фукнція, функція іншого класу чи інший клас (при цьому функція такого классу стають друзями поточному
)), яким може звертатис до захиченних та приватних єлементів класу.

Класс самостійно визначає своіх Friend шляхом ії декларації в класі з ключовий словом Friend.

```cpp
void f1() {};

class X {
   void f2();
}

class Y {
   void f2();
}

class Z {
   friend void f1();
   friend void X::f2();
   friend Y;
}
```

Може знадобитись якщо деякі функції мають одночасно належати декільком классам.

*Дружба порушує принципи інкапсуляції*

3.Спеціальні функції классу і перевантаження операторів
---

3.1. Ініціалізація і очистка об'єктів классу
---

3.1.1. Конструктори
---

































